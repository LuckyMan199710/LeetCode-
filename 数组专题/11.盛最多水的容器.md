### 盛最多水的容器(难度：中等)

给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。

说明：你不能倾斜容器。

示例 1：

![](https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg)
```
输入：[1,8,6,2,5,4,8,3,7]
输出：49 
解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。
```
示例 2：
```
输入：height = [1,1]
输出：1
```
示例 3：
```
输入：height = [4,3,2,1,4]
输出：16
```
示例 4：
```
输入：height = [1,2,1]
输出：2
```

### 解题思路
我们先明确一下这道题要我们做什么，其实这道题就是在要求你找出x，y轴所围成的最大矩形面积，x轴位置用数组的index表示，y轴则用value表示。

**双指针**

要算面积的话，那就需要宽和高，所以我们要先确立两个点，并算出面积，所以就可以使用双指针来处理这个问题。

我们先设置两个指针i、j，分别指向数组的第一个和最后一个的index，首先我们先明确一下面积的计算公式：min(height[i] , height[j])\*(j-i)。两条边中的最短边为高，index的差值为宽。

我们默认一开始的面积为最大的面积。然后接下来要**移动短边的指针**。这里我们说一下为什么要移动短边的指针：

通过计算公式min( height[i] , height[j] )\*(j-i)我们可以知道如果移动了指针的话j-i是必然在变小的，但是当移动短边，min(height[i] , height[j])可能变大；如果移动长边，min(height[i] , height[j])不变甚至变小。因此就可以得出结论，如果移动长边，后面计算的面积绝对比当前面积小，所以不可以移动长边。

所以我们每次移动短边，算出面积，然后再和上次的面积做对比，每次只留下最大的面积，当i和j重合时，已经不可能围成矩形了，此时退出计算，最终留下来的面积就是最大值。

```JavaScript
var maxArea = function(height) {
    let i = 0,j = height.length - 1,res = 0;
    while(i < j){
        if(height[i] < height[j] ){
            res = Math.max( res, height[i]*(j-i))
            i++
        } else{
            res = Math.max( res, height[j]*(j-i))
            j--
        }
    }
    return res
};
```