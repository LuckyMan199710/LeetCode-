### 寻找重复数(难度：中等)


给定一个包含 n + 1 个整数的数组 nums ，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。

假设 nums 只有 一个重复的整数 ，找出 这个重复的数 。

你设计的解决方案必须不修改数组 nums 且只用常量级 O(1) 的额外空间。

示例 1：
```
输入：nums = [1,3,4,2,2]
输出：2
```
示例 2：
```
输入：nums = [3,1,3,4,2]
输出：3
```
示例 3：
```
输入：nums = [1,1]
输出：1
```
示例 4：
```
输入：nums = [1,1,2]
输出：1
```

提示：
1 <= n <= 105
nums.length == n + 1
1 <= nums[i] <= n
nums 中 只有一个整数 出现 两次或多次 ，其余整数均只出现 一次


进阶：
如何证明 nums 中至少存在一个重复的数字?
你可以设计一个线性级时间复杂度 O(n) 的解决方案吗？

#### 解题思路
这道题因为有空间复杂度的要求、所以不能采用额外的空间来处理。
采用标记法也可以解决，但是因为不允许改变本身的数据，所以也不能使用。

1. 二分查找
这道题我们需要抓住一个点：它是一个1到n之间，长度为n+1的数组。所以，在无重复的情况下，**小于该区间中某个数字的个数**一定是小于等于**该数字本身**。假如数组为[1,2,3,4] 那么小于等于2的个数只有2个，小于等于3的个数只有3个。假如小于等于3的个数有4个，那么在[1,3]区间内必定有重复数字

知道了这个解法之后，我们每次可以取一个在区间里面的中间数mid，并且统计小于等于mid的数量。如果大于mid，则表示重复的数字在[1,mid]之间，否则就是在[mid+1，n]之间，反复执行直到找出结果。代码如下：
```javascript
var findDuplicate = function(nums) {
    const length = nums.length;
    let left = 1, right = length - 1;
    
    while( left < right ){
        let mid = Math.floor((left+right)/2)
        let count = 0;
        for(let num of nums){
            if(num <= mid){
                count++;
            }
        }
        if( count > mid){
            right = mid;
        }else{
            left = mid+1;
        }
    }
    return left
};
```
2. 快慢指针(Floyd 判圈算法)
这个算法在141题和142环形链表中用到，如果快指针能够在某个时刻和慢指针再次重逢，那么就证明有环的存在。
这道题我们需要将数组抽象成一个链表来看待，假如数组nums是[1,3,4,2,2]我们可以将其下标和idx和nums[idx]映射起来，如下：
0 -> 1
1 -> 3
2 -> 4
3 -> 2
4 -> 2
我们可以看到2指向了4，4又指回了2，这里就形成了一个环，环的入口就是2，也就是重复的数字。
我们定义快慢指针，快指针走两步，慢指针走一步,，然后算出它们在环中相遇的点。
```JavaScript
    // 双指针会在环中的某处相遇
    while (slow != fast) {
        slow = nums[slow]; // 走一步 相当于p.next
        fast = nums[nums[fast]]; // 走两步 相当于p.next.next
    }
```
但是这里只是算出2个指针相遇在环中的点，并不能证明这个点是环的入口。这个时候我们将慢指针重新放回起点，然后两个指针按相同的速度移动，最后必定在入口位置相遇，也就是重复的数字。

为什么将一个指针放回起点，再按相同速度移动，就必定在入口相遇呢？这里需要一个数学公式的推导，搬自官方题解：
```
  这里简单解释为什么后面将slow 放置起点后移动相遇的点就一定是答案了。假设环长为L，从起点到环的入口的步数是a，从环的入口继续走b步到达相遇位置，从相遇位置继续走c步回到环的入口，则有b+c=L，其中L、a、b、c都是正整数。根据上述定义，慢指针走了a+b步，快指针走2(a+b)步。从另一个角度考虑，在相遇位置，快指针比慢指针多走了若干圈，因此快指针走的步数还可以表示成a+b+kL，其中k表示快指针在环上走的圈数。联立等式，可以得到
            2(a+b)=a+b+kL
解得a=kL-b，整理可得
			a=(k-1)L+(L-b)=(k-1)L+c
```
这里我们可以看到最后的等式就是**a = (k-1)L+c**，(k-1)L表示快指针已经绕了这么多圈，所以可以忽略掉，所以最后就是**a=c**，表示**从起点到环入口的距离**和**从两指针在环内的相遇点到入口的距离**是一样的。所以必定在环的入口相遇。详细代码如下：
```JavaScript
var findDuplicate = function(nums) {
    let slow = 0, fast = 0;
    slow = nums[slow];
    fast = nums[nums[fast]];
    // 双指针会在环中的某处相遇
    while (slow != fast) {
        slow = nums[slow]; // 走一步
        fast = nums[nums[fast]]; // 走两步
    }
    slow = 0;
    while(slow != fast){
        slow = nums[slow]
        fast = nums[fast]
    }
    return slow
};
```

