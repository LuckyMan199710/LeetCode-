### 相同的树(难度:简单)

#### 题目要求

给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。

如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。

示例 1：
```
输入：p = [1,2,3], q = [1,2,3]
输出：true
```
示例 2：

```
输入：p = [1,2], q = [1,null,2]
输出：false
```
示例 3：
```
输入：p = [1,2,1], q = [1,1,2]
输出：false
```

#### 解题思路

这道题可以采用**深度优先遍历**处理，我们需要先罗列出判断两棵树相同或者不同的条件。
1. 如果两棵树的根节点都是空的，既p、q都为null，则返回true，表示两棵树相同。
2. 如果两棵树的相同位置的节点有一个为null，另一个不为null，返回false，表示两棵树不相同。
3. 如果两棵树都不为空，那么进行递归比较，先判断根节点的值是否相同，然后再判断左右子树的值是否相同，如果发现不同则返回false，表示两棵树不相同。

下面是深度优先遍历的代码：
```JavaScript
var isSameTree = function(p, q) {
    if(q === null && p === null) return true
    if( q === null  || p === null ) return false
    if(p.val !== q.val) return false
    return isSameTree(q.left,p.left) && isSameTree(q.right,p.right)
};
```

深度优先遍历还有一种非递归的写法，如下：
```JavaScript
var isSameTree = function(p, q) {
    // 两棵树根节点为空
    if(p === null && q === null) return true
    let stackQ = [],stackP = []
    stackP.push(p)
    stackQ.push(q)
    
    while(stackP.length && stackQ.length){
        let nodeP = stackP.pop()
        let nodeQ = stackQ.pop()
		// 两棵树左节点或者有右节点都是null 直接跳过
        if( !nodeQ && !nodeP ) continue 
        // 如果一棵树的某个左节点或右节点为空 另一棵树不为空 不可能相等 返回false
        if( !nodeQ || !nodeP ) return false; 
        // 节点值不相等 返回false
        if( nodeQ.val !== nodeP.val ) return false; 
       
        stackP.push(nodeP.right)
        stackP.push(nodeP.left)

        stackQ.push(nodeQ.right)
        stackQ.push(nodeQ.left)
    }
    return true
};
```

